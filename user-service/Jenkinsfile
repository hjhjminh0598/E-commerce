// Jenkinsfile for E-commerce Monorepo - User Service CI

pipeline {
    agent any // Runs on the Jenkins master VM (which has Docker, gcloud, Java, Maven)

    tools {
        // Ensure these tool names match what you configured in Jenkins Global Tool Configuration
        maven 'MAVEN_HOME' // e.g., MAVEN_HOME, or your chosen name
        jdk 'JDK_17'       // e.g., JDK_17, or your chosen name
    }

    environment {
        // Variables specific to this service's pipeline
        SERVICE_NAME                = 'user-service'
        SERVICE_DIR                 = 'user-service' // Subdirectory in your monorepo for this service
        GCP_PROJECT_ID              = 'fresh-replica-458307-s5'
        GAR_LOCATION                = 'us'
        GAR_REPOSITORY              = 'gcr.io'
        // IMAGE_TAG will use the Jenkins build number for uniqueness and amd64 indication
        IMAGE_TAG                   = "build-${env.BUILD_NUMBER}-amd64"
    }

    stages {
        stage('Checkout Code') {
            steps {
                echo "Checking out code from SCM for ${env.SERVICE_NAME}..."
                // This checks out the entire E-commerce repository.
                // The 'dir' step in subsequent stages will navigate to the correct subdirectory.
                checkout scm
            }
        }

        stage('Build Application') {
            steps {
                // Navigate to the specific service's directory before running Maven
                dir(env.SERVICE_DIR) {
                    echo "Building ${env.SERVICE_NAME} with Maven..."
                    // Assuming pom.xml is in the root of the SERVICE_DIR (e.g., user-service/pom.xml)
                    sh 'mvn clean package -DskipTests'
                }
            }
        }

        stage('Build and Push Docker Image') {
            steps {
                // Navigate to the service's directory where its Dockerfile is located
                dir(env.SERVICE_DIR) {
                    script {
                        def fullImageName = "${env.GAR_LOCATION}-docker.pkg.dev/${env.GCP_PROJECT_ID}/${env.GAR_REPOSITORY}/${env.IMAGE_NAME}:${env.IMAGE_TAG}"
                        echo "Building and pushing Docker image: ${fullImageName}"

                        // Authenticate Docker to Google Artifact Registry.
                        // This uses the GCE VM's attached service account permissions.
                        // Ensure the VM's service account has "Artifact Registry Writer" role.
                        sh "gcloud auth configure-docker ${env.GAR_LOCATION}-docker.pkg.dev --quiet"

                        // Build and push.
                        // The Jenkins VM (GCE e2-medium) is amd64, so it will build an amd64 image.
                        // Using --platform linux/amd64 is still good practice for explicitness.
                        // Assumes Dockerfile is in the root of SERVICE_DIR (e.g., user-service/Dockerfile)
                        sh "docker buildx build --platform linux/amd64 -t ${fullImageName} --push ."

                        echo "Successfully pushed ${fullImageName}"
                    }
                }
            }
        }
    }

    post {
        always {
            echo 'Pipeline finished.'
            // Optional: Clean up workspace to save disk space on Jenkins master
            // cleanWs()
        }
        success {
            echo "Pipeline Succeeded: ${env.IMAGE_NAME}:${env.IMAGE_TAG} pushed to GAR."
        }
        failure {
            echo 'Pipeline failed. Check console output for details.'
        }
    }
}